<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doctor D64</title>
    <link rel="icon" href="img/icon.png">
    <style>
        /* Dark Mode Styles for the tabs and content */
        body {
            background-color: #121212;
            color: #FFFFFF;
        }

        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .tab {
            padding: 10px 20px;
            border: 1px solid #555;
            cursor: pointer;
            background-color: #242424;
            transition: background-color 0.2s;
        }

        .tab:hover {
            background-color: #444;
        }

        .tab.active {
            background-color: #0077FF; /* Highlighted background color for active tab */
            color: #FFFFFF;
        }

        .content {
            display: none;
            border: 1px solid #555;
            padding: 20px;
            background-color: #242424;
        }

        .content.active {
            display: block;
        }

        h1, h2, p {
            color: #ffc107; /* Yellow color for headings and text */
        }

        input, button {
            background-color: #222; /* Dark background for input and button */
            color: #ffffff;
            border: none;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background-color: #444; /* Darken button on hover */
        }

        pre {
            background-color: #333; /* Dark background for output area */
            color: #ffffff;
            padding: 10px;
            border-radius: 4px;
        }


        @font-face{font-family:"C64 Pro Mono Local";src:url(fonts/C64_Pro_Mono-STYLE.ttf) format("truetype")}
        .c64pm{font:normal 12pt/16px "C64 Pro Mono Local",verdana,helvetica,sans-serif;letter-spacing:0;padding:0;margin:0}
        .ascii{

            font-family: 'Courier New', Monaco, Consolas, 'Lucida Console', monospace;
            font-size: 16px; /* Adjust as needed */            
            font-weight: bold;
            letter-spacing:0;
            padding:0;
            margin:0
        }

        .bigger{

            font-size: 20px; /* Adjust as needed */            
        }        

    </style>
</head>
<body>

<div class="tabs">
    <div class="tab active" onclick="toggleTab('main')">Main</div>
    <div class="tab" onclick="toggleTab('list')">List</div>
    <div class="tab" onclick="toggleTab('multiList')">Multi List</div>
</div>

<div class="content active" id="main">
    <h1>Doctor D6</h1>
    <p>Examine D64 files directly from your browser</p>
    <img src="img/logo.png"><br>
</div>

<div class="content" id="list">
    <h1>List</h1>
    <p>List the contents of a single D64 file.</p>

    <div>
        <label for="D64DetailedMode">Detailed Mode:</label>
        <input type="checkbox" id="D64DetailedMode">
    </div>
    <div>
        <label for="D64PETSCIIMode">PETSCII Mode:</label>
        <input type="checkbox" id="D64PETSCIIMode">
    </div>

    <div>
        <input type="file" id="D64FileInput" accept=".D64, .d64">
    </div>

    <div>
        <button class="bigger" id="D64UploadButton">List</button>
    </div>

    <h2>Directory Information</h2>
    <p><strong>Directory Entries:</strong></p>
    <p id="D64DiskTitle"></p>
    <pre class="c64pm" id="D64DirectoryEntries"></pre>
    <p id="D64DiskFree"></p>

</div>

<div class="content" id="multiList">
    <h1>Multi List</h1>
    <p>List the contents of multiple D64 files. (provided as a ZIP)</p>

    <div>
        <label for="ZIPConcateningMode">Concatenating Mode:</label>
        <input type="checkbox" id="ZIPConcateningMode">
    </div>
    <div>
        <input type="file" id="zipFileInput"  accept=".ZIP, .zip">
    </div>
    <div>
        <button onclick="copyZipContentToClipboard()">Copy</button>
    </div>

    <div id="extractedFiles"></div>


        
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip-utils/0.1.0/jszip-utils.min.js"></script>

<script>

    var diskImages = [];
    var ZipContentAsText = ""; 

    function checkD64FileExtension( filePath ) {

        const fileName = filePath;
        
        // Extract the file extension
        const extension = fileName.slice((fileName.lastIndexOf(".") - 1 >>> 0) + 2); 
        
        // Check if the extension is 'd64' (case insensitive)
        if(extension.toLowerCase() === 'd64'.toLowerCase()) {
            return true;
        } else {
            return false;
        }
    }

    function checkZIPFileExtension( filePath ) {

        const fileName = filePath;
        
        // Extract the file extension
        const extension = fileName.slice((fileName.lastIndexOf(".") - 1 >>> 0) + 2); 
        
        // Check if the extension is 'd64' (case insensitive)
        if(extension.toLowerCase() === 'zip'.toLowerCase()) {
            return true;
        } else {
            return false;
        }
    }


    function blobToArrayBuffer(blob, callback) {
        const reader = new FileReader();

        reader.onload = function(event) {
            const arrayBuffer = event.target.result;
            callback(arrayBuffer);
        };

        reader.readAsArrayBuffer(blob);
    }


    function copyZipContentToClipboard() {
        navigator.clipboard.writeText(ZipContentAsText).then(function() {
        console.log('Text successfully copied to clipboard');
        alert( "Copied to Clipboard");
    }).catch(function(err) {
        console.error('Unable to copy text to clipboard', err);
    });
    }


    

    document.getElementById("zipFileInput").addEventListener("change", function(event) {
      //let fileList = document.getElementById("fileList");
      //fileList.innerHTML = ""; // Clear any previous listings
  
      let extractedFilesDiv = document.getElementById("extractedFiles");
      let file = event.target.files[0];

      if( !checkZIPFileExtension ( file.name ) ) {
        alert("Only ZIP files supported");
        return;
      }   

      const ZIPConcateningCheckBox = document.getElementById('ZIPConcateningMode').checked;

   

      if( ZIPConcateningCheckBox == false) {
        extractedFilesDiv.innerHTML = '';
        ZipContentAsText = "";
      }
      JSZip.loadAsync(file).then(function(zip) {

            diskImages = [];
            var fileCount = Object.keys(zip.files).length;

//            var lastFile = "";
//            for( var i=0; i<Object.keys(zip.files).length; i++ ) {
//                var file = Object.keys(zip.files)[i];
//                if( checkD64FileExtension( file )  ) {
//                    lastFile = file;
//                }
//            }

//           if( fileCount > 0) { 
//                //lastFile = zip.files[fileCount-1];
//                lastFile = Object.keys(zip.files)[fileCount-1];
//            }

            zip.forEach(function(relativePath, zipEntry) {

             
                  zipEntry.async("blob").then(function(content) {

                      if( !checkD64FileExtension( relativePath ) ) {
                        return;
                      }   

                      blobToArrayBuffer(content, function(arrayBuffer) {
                        // Use the arrayBuffer as needed
                        console.log(arrayBuffer);

                        //var buffer = stringToBinaryArray(content);    
                        let image = { path: relativePath, content: new D64Disk( arrayBuffer, relativePath ) };

                        diskImages.push( image );
                        let fileDiv = document.createElement("div");
                        var list = image.content.directory.getEntriesAsText( true );
                        fileDiv.innerHTML = `<strong>${relativePath}:</strong><pre>${list}</pre>`;
                        extractedFilesDiv.appendChild(fileDiv);                        
                        
                        ZipContentAsText += `${relativePath}\n-------------\n${list}\n`;
                        
//                        if( relativePath == lastFile ) {
//                            
//                            copyToClipboard( ZipContentAsText );
//                        }

                        
                      });
                  });
              });
          });
    });
  


  
  function extractFiles() {
      let fileInput = document.getElementById("zipFileInput");
      let file = fileInput.files[0];
      let extractedFilesDiv = document.getElementById("extractedFiles");
      extractedFilesDiv.innerHTML = ""; // Clear any previous listings
  
      if (file) {
          JSZip.loadAsync(file).then(function(zip) {
              zip.forEach(function(relativePath, zipEntry) {
                  zipEntry.async("text").then(function(content) {
                      let fileDiv = document.createElement("div");
                      fileDiv.innerHTML = `<strong>${relativePath}:</strong><pre>${content}</pre>`;
                      extractedFilesDiv.appendChild(fileDiv);
                  });
              });
          });
      } else {
          alert("Please select a zip file first!");
      }
  }
      </script>


<script>
    function toggleTab(pageId) {
        // Get all content divs and tabs
        let contents = document.querySelectorAll('.content');
        let tabs = document.querySelectorAll('.tab');

        // Hide all content divs and remove active state from tabs
        contents.forEach(content => content.classList.remove('active'));
        tabs.forEach(tab => tab.classList.remove('active'));

        // Display the selected content div and set its tab to active state
        document.getElementById(pageId).classList.add('active');
        [...tabs].find(tab => tab.getAttribute("onclick").includes(pageId)).classList.add('active');
    }

    toggleTab('list')




    class D64Disk {

    constructor(arrayBuffer, fn ) {
        this.byteArray = new Uint8Array(arrayBuffer);
        this.tracks = [];
        this.currentPosition = 0;
        this.maxSectors = 683;

        var checkSum = 0;
        for( var i=0; i<this.byteArray.byteLength; i++) {
            checkSum += this.byteArray[ i ];
        }

        console.log( "image file: " + fn );
        console.log( "checkSum: " + checkSum );
        console.log( "binary length: " + this.byteArray.byteLength );

        // Initialize tracks
        this.tracks.push(null); // Placeholder for track 0
        for (let trackNumber = 1; trackNumber <= 40; trackNumber++) {
            this.tracks.push(this.processDiskTrack(trackNumber));
        }

        // Populate the directory
        const directorySector = this.tracks[18].sectors[1];
        
        if( fn === undefined ) {
            this.imageFileName = "UNKNOWN";
        }
        else {
            this.imageFileName = fn; 
        }

        this.directory = new Directory(directorySector, this);
        
    }

    setImageFileName( fn ) {
        this.imageFileName = fn;
    }

    processDiskTrack(trackNumber) {
        let sectorCount;
        if (trackNumber <= 17) {
            sectorCount = 21;
        } else if (trackNumber <= 24) {
            sectorCount = 19;
        } else if (trackNumber <= 30) {
            sectorCount = 18;
        } else {
            sectorCount = 17;
        }

        const sectors = [];
        for (let i = 0; i < sectorCount; i++) {
            sectors.push(this.byteArray.subarray(this.currentPosition, this.currentPosition + 256));
            this.currentPosition += 256;
        }

        return {
            trackNumber: trackNumber,
            sectors: sectors,
            byteOffset: this.currentPosition - 256 * sectorCount
        };
    }

    getDiskTitle(bamSector) {
        const diskTitleBytes = bamSector.subarray(0x90, 0xA0);
        const diskTitle = String.fromCharCode(...diskTitleBytes);
        return diskTitle;
    }

    getFreeSectors() {
        const usedSectors = this.directory.entries.reduce((total, entry) => total + entry.fileLength, 0);
        const freeSectors = this.maxSectors - usedSectors;
        return freeSectors;
    }

}

class DirectoryEntry {
    constructor(directoryEntryBytes) {

        this.fileType = 0;
        this.fileName = "UNDEFINED";
        this.fileNameBinary= null;
        this.fileLength = 0;
        this.nextTrack = 0;
        this.nextSector = 0;
        this.fileStartTrack = 0; // New field
        this.fileStartSector = 0; // New field   

        if( directoryEntryBytes === undefined ) { ; }
        else {

            this.fileType = directoryEntryBytes[2].toString(16).padStart(2, '0');
            this.fileName = String.fromCharCode(...directoryEntryBytes.subarray(5, 21));
            this.fileNameBinary=( directoryEntryBytes.subarray(5, 21) );
            this.fileLength = (directoryEntryBytes[0x1F] << 8) + directoryEntryBytes[0x1E]; // Swapped length bytes
            this.nextTrack = directoryEntryBytes[0];
            this.nextSector = directoryEntryBytes[1];
            this.fileStartTrack = directoryEntryBytes[3]; // New field
            this.fileStartSector = directoryEntryBytes[4]; // New field

        }
    }

    setFileName( name ) {
        this.fileName = name;
    }

    convertD64FileHexTypeToText() {
        switch (this.fileType) {
            case '80':
                return 'DEL';
            case '81':
                return 'SEQ';
            case '82':
                return 'PRG';
            case '83':
                return 'USR';
            case '84':
                return 'REL';
            case '80':
                return 'DEL';
            case '81':
                return 'SEQ';
            case '82':
                return 'PRG';
            case '83':
                return 'USR';
            case '84':
                return 'REL';
            case 'c0':
                return 'DEL<';
            case 'c1':
                return 'SEQ<';
            case 'c2':
                return 'PRG<';
            case 'c3':
                return 'USR<';
            case 'c4':
                return 'REL<';
            case 'c0':
                return 'DEL<';
            case 'c1':
                return 'SEQ<';
            case 'c2':
                return 'PRG<';
            case 'c3':
                return 'USR<';
            case 'c4':
                return 'REL<';                


            default:
                return '???';

        
        }
    }
}


class Directory {
    constructor(directorySector, disk) {
        this.entries = [];
        this.processDirectory(directorySector, disk);
    }

    processDirectory(directorySector, disk) {
        const directoryEntries = [];

        while (true) {
                this.processDirectorySector(directorySector, directoryEntries);

                const nextDirectoryTrack = directorySector[0];
                const nextDirectorySector = directorySector[1];

                if (nextDirectoryTrack === 0 || nextDirectorySector === 255) {
                    break; // No next directory sector
                }

                //if (nextDirectorySector === 255) {
                //    break; // No next directory sector
                //}

                if( nextDirectoryTrack == 0 || nextDirectoryTrack>40 ) {
                    
                    var dummy = new DirectoryEntry( undefined );
                    dummy.setFileName("ERROR: Wrong next directory track T"+ nextDirectoryTrack +" (S"+nextDirectorySector+")" );
                    directoryEntries.push( dummy );
                    break;
                }

                var nextTrack = disk.tracks[nextDirectoryTrack];
                if( nextDirectorySector >= nextTrack.sectors.length ) {
                    var dummy = new DirectoryEntry( undefined );
                    dummy.setFileName("ERROR: Non existent next directory track/sector T" + nextDirectoryTrack +" S"+nextDirectorySector );
                    directoryEntries.push( dummy );
                    break;

                }
                    
                directorySector = disk.tracks[nextDirectoryTrack].sectors[nextDirectorySector];
        }

        this.entries = directoryEntries;
    }

    processDirectorySector(directorySector, directoryEntries) {
        for (let entryIndex = 0; entryIndex < 8; entryIndex++) {
            const directoryEntryOffset = entryIndex * 32;
            const directoryEntryBytes = directorySector.subarray(directoryEntryOffset, directoryEntryOffset + 32);

            const fileType = directoryEntryBytes[2];
            if (fileType === 0) {
                continue; // Skip unused entries
            }

            const directoryEntryObject = new DirectoryEntry(directoryEntryBytes);
            directoryEntries.push(directoryEntryObject);
        }
    }

    convertPETSIIByteArrayToAsciiString(byteArray) {

        let result = '';

        for (let i = 0; i < byteArray.length; i++) {
            const byte = byteArray[i];
            if (byte >= 32 && byte <= 93) {
                result += String.fromCharCode(byte);
            } 
            else if( byte ==160) {
                result += " ";
            }            
            else {
                result += "?";
            }
            
            
        }

        return result;
    }


    convertPETSIIByteArrayToHTML(byteArray) {

        let result = '';

        for (let i = 0; i < byteArray.length; i++) {
            const byte = byteArray[i];
            if (byte >= 32 && byte <= 93) {
                result += String.fromCharCode(byte);
            } else if( byte >= 94 && byte <= 127) {
                let code = `0ee${(byte-32).toString(16).padStart(2, '0')}`;
                const charCode = parseInt( code , 16);
                result += String.fromCharCode(charCode);;
            }
            else if( byte ==160) {
                result += " ";
            } else if( byte >= 161 && byte <= 255) {
                let code = `0ee${(byte-64).toString(16).padStart(2, '0')}`;
                const charCode = parseInt( code , 16);
                result += String.fromCharCode(charCode);;
            }
            else {
                let code = `0ee00`;
                const charCode = parseInt( code , 16);
                result += String.fromCharCode(charCode);;
            }
            
            
        }

        return result;
    }


    getEntriesAsText(shortMode) {
        let entriesText = '';

        this.entries.forEach((entry, index) => {


            let asciiName;

            asciiName = entry.fileName;
            if( entry.fileNameBinary != null ) {
                asciiName = this.convertPETSIIByteArrayToAsciiString( entry.fileNameBinary );
            }

            if (shortMode) {

                //
                
                entriesText += `${entry.fileLength}\t"${asciiName}" ${entry.convertD64FileHexTypeToText()}`
                entriesText += `\n`;

                //DEBUG entriesText += `\tN:T${entry.nextTrack}S${entry.nextSector} \n`;
            } else {
                entriesText += `Entry ${index + 1}:\n`;
                entriesText += `  File Type: 0x${entry.fileType}\n`;
                entriesText += `  File Name: ${asciiName}\n`;
                entriesText += `  File Length: ${entry.fileLength}\n`;
                entriesText += `  Next Track: ${entry.nextTrack}\n`;
                entriesText += `  Next Sector: ${entry.nextSector}\n`;
                entriesText += `  File Start Track: ${entry.fileStartTrack}\n`;
                entriesText += `  File Start Sector: ${entry.fileStartSector}\n\n`;
            }
        });

        return entriesText; // Display or use the entries text as needed
    }

    getEntriesAsInnerPETSCIIHTML(shortMode) {
        let entriesText = '';

        this.entries.forEach((entry, index) => {

            let petsciiName;
            petsciiName = entry.fileName;
            if( entry.fileNameBinary != null ) {
                petsciiName  = this.convertPETSIIByteArrayToHTML( entry.fileNameBinary );
            }

            if (shortMode) {
    
                entriesText += `${entry.fileLength}\t"${petsciiName}" ${entry.convertD64FileHexTypeToText()}<br>`;
            } else {
                entriesText += `Entry ${index + 1}:<br>`;
                entriesText += `  File Type: 0x${entry.fileType}<br>`;
                entriesText += `  File Name: ${petsciiName}<br>`;
                entriesText += `  File Length: ${entry.fileLength}<br>`;
                entriesText += `  Next Track: ${entry.nextTrack}<br>`;
                entriesText += `  Next Sector: ${entry.nextSector}<br>`;
                entriesText += `  File Start Track: ${entry.fileStartTrack}<br>`;
                entriesText += `  File Start Sector: ${entry.fileStartSector}<br><br>`;
            }
        });        

        return entriesText; // Display or use the entries text as needed
    }
}


function handleD64ListRequest() {
    const fileInput = document.getElementById('D64FileInput');
    if( !checkD64FileExtension ( fileInput.value ) ) {
        alert("Only D64 images supported");
        return;
    }


    const directoryEntriesElement = document.getElementById('D64DirectoryEntries');
    const shortModeCheckbox = !document.getElementById('D64DetailedMode').checked;
    const PETSCIIModeCheckbox = document.getElementById('D64PETSCIIMode').checked;
    
    const diskTitleElement = document.getElementById('D64DiskTitle');
    const diskFreeElement = document.getElementById('D64DiskFree');

    const file = fileInput.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function (e) {
            const d64Disk = new D64Disk(e.target.result);

            if( PETSCIIModeCheckbox ) {
                var text = d64Disk.directory.getEntriesAsInnerPETSCIIHTML(shortModeCheckbox);
                directoryEntriesElement.innerHTML = text;
                directoryEntriesElement.className = "c64pm";
            }
            else {
                var text = d64Disk.directory.getEntriesAsText(shortModeCheckbox);
                directoryEntriesElement.textContent = text;
                directoryEntriesElement.className = "ascii";
            }
            
            diskTitleElement.textContent = `Disk Name: "${d64Disk.getDiskTitle(d64Disk.tracks[18].sectors[0])}"`;
            diskFreeElement.textContent = `Free: ${d64Disk.getFreeSectors()} blocks / sectors`;
        };

        reader.readAsArrayBuffer(file);
    }
}


// Attach event listener
document.getElementById('D64UploadButton').addEventListener('click', function () {
    handleD64ListRequest();
});

document.getElementById('D64FileInput').addEventListener('change', function () {
    handleD64ListRequest();
});

document.getElementById('D64DetailedMode').addEventListener('change', function () {
    handleD64ListRequest();
});

document.getElementById('D64PETSCIIMode').addEventListener('change', function () {
    handleD64ListRequest();
});

</script>

</body>
</html>
